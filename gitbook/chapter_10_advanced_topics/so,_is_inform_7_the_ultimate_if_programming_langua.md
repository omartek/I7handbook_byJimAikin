## So, Is Inform 7 the Ultimate IF Programming Language?

Given the popularity of Inform 7 and the ease with which newcomers can use it to start creating their own interactive fiction, it wouldn’t be surprising if people get the impression it’s the best IF development system that could ever be imagined. It would be wrong for this _Handbook_ to draw to a close without commenting on that impression.

For all its strengths, Inform has some surprising weaknesses, some of them trivial, others a bit more awkward to deal with. A few of them have been touched on in the course of this book. Obviously, I feel that Inform is a very good language with which to approach writing interactive fiction, especially if you’re new to computer programming. But my enthusiasm has more to do with Inform’s approachability — its “natural language” syntax and its cross-platform IDE — than with the nuts and bolts of its design.

Some of its limitations seem to have arisen out of Graham Nelson’s desire to preserve backward compatibility with older IF systems — not just Inform 6 but earlier systems dating back to the 1980s, when Infocom was still an active company releasing new text-based games. The fact that a game’s release number (displayed in the banner at the beginning of the game) can’t have decimal places, but can only be an integer, seems to have no rational basis other than the fact that that’s how Infocom did it. Today, the standard in version numbering often includes not one but two decimal points — version 1.5.2, for instance. Inform just plain can’t number your game’s version that way.

To be sure, that’s a trivial issue. A more serious example is the separation between .z8 game files on the one hand and Glulx files on the other. The Z-machine format is an artifact of a bygone era. In those days, computers typically had less than a megabyte of memory, so the .z8 format simply can’t be used with large files. There’s no real reason why this format should still be supported today, except for the large installed base of Z-machine interpreters. On the other hand, the Z-machine is actually more powerful than a Glulx interpreter in a few restricted circumstances having to do with type styles; Glulx is, at this writing, still rather poor at allowing the author to create a variety of new type styles.

Other limitations or odd design choices seem to have arisen due to the piecemeal fashion in which Inform was developed. Because its syntax is very unlike the syntax of any other programming language, and because Nelson wanted the code to read as much like English as possible, he seems to have made some choices along the way that were less systematically consistent than _ad hoc_. If you’ve created a backdrop called the sky, for instance, you’ll find that in some code statements you can refer simply to “the sky”, while in others you have to refer to “the sky backdrop,” as explained on **p. 8.8** of _Writing with Inform._

The fact that doors can’t be moved probably simplifies the way Inform works internally, but in terms of the limitations it places on the author, it was a poor design choice. No more need be said about that.

Another limitation, and one that is of concern to a lot of authors, is that Inform insists that all of the code for your game be stored in a single file. No other modern programming language operates this way; the norm among programmers is to store the code for a single project in several files, which can be edited (and compiled) separately. There are several reasons why forcing all the code for a game to live in a single file was a debatable design choice: It makes collaborating with other authors more difficult, it makes editing more difficult, and so on. The fact that the code file is always called story.ni can also become a problem, because it makes the process of archiving successive versions of a single project during development a bit more cumbersome and error-prone than it needs to be.

At the code design level, Inform doesn’t allow multiple inheritance. For instance, a single object can’t be both a device and a supporter. Lacking the ability to create such an object, the author has to choose a workaround in order to create as standard an in-game object as a stove. The workarounds are not, in most cases, difficult to work with. Usually, you can make one object a part of another object, and you’ll be ready to move on. For that matter, Inform’s device class is so bare-bones that there’s almost no reason to use it at all. But the absence of multiple inheritance can occasionally force the author to perform a few gyrations.

If you want to really master the deepest level of Inform 7 programming, you’ll have no choice but to learn an entirely new and much more abstract set of code syntax: Inform 6\. Learning two separate coding systems means extra work. To be sure, Inform is not the only computer language that works this way: Musicians who use Csound, for instance, can get at some of its deeper features only by learning to program in Python or C. But most interactive fiction authoring systems are not bifurcated in this way. TADS 3 can be entirely customized by writing new code that uses exactly the same syntax you would use to write your game (though the extensive use of macros and templates in game programming somewhat obscures this fact). TADS has a much more extensive built-in library than Inform, implements multiple inheritance, and handles type styles, clickable hyperlinks, and multimedia. (Also, the TADS Workbench has tools for professional-level debugging, such as stepping through the code one line at a time. On the other hand, Workbench is a Windows-only program. To use it on a MacOS or Linux computer, you have to run a Windows emulator.)

In sum — no, Inform 7 is not the be-all or end-all. Even so, there’s no denying that it’s powerful, popular, well-supported, and quite easy to use, and has a number of terrific features. For many aspiring authors, it will be absolutely the right choice. Because it’s still being developed, certain of the issues mentioned in this concluding section of the 2009 edition of the _Handbook_ have already been dealt with. And the developers of extensions for Inform have added, and continue to add, some powerful and unexpected capabilities. If you’re new to writing IF, you need have no fear that in choosing Inform 7, you’re painting yourself into a corner or headed down a dark alley. You can have confidence that you’re making a wise choice, that you’ll be able to produce games of amazing complexity and high quality.

All it takes is thick slabs of inspiration and months of hard work, coupled with generous amounts of head-scratching, hair-pulling, and teeth-grinding. Really, you hardly ever need to throw your computer across the room in sheer frustration. Once in a while, you may notice that you’re actually having fun. And that’s the point, isn’t it?
